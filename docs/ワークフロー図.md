# ticket-tasuki ワークフロー図

## 前提

- **方式E（Agent Teams + sendmessage_guard）**を使用
- Leader = チームリーダー（人間のプロキシ）。読む・判断する・指示する・レビューする
- メンバー間通信はissue_idのみ（sendmessage_guardで強制）
- 詳細情報は全てRedmineチケットコメントに記載
- LeaderConstraintHookにより、leaderはsubagent存在時に直接コード編集不可

## 全体フロー

```mermaid
flowchart TB
    subgraph 要件定義フェーズ
        A[PO: 要件伝達] --> B[Leader: 受領・分析]
        B --> C[Scribe: チケット起票]
    end

    subgraph 技術調査・意思決定フェーズ
        C --> D[Leader: 技術調査・pro/con整理]
        D --> E[PO: 方針決定]
        E --> F[Scribe: タスク分解・子チケット起票]
    end

    subgraph 実装フェーズ【並列可】
        F --> G1[Coder: issue_101]
        F --> G2[Coder: issue_102]
        G1 --> H[Leader: 実装レビュー]
        G2 --> H
    end

    subgraph レビュー・修正ループ
        H --> I{レビューOK?}
        I -->|No| J[Coder: 修正]
        J --> H
        I -->|Yes| K[テストフェーズへ]
    end

    subgraph テストフェーズ
        K --> L[Tester: テスト実行]
        L --> M[Leader: テスト結果確認]
    end

    subgraph 受入フェーズ
        M --> N[PO: 成果物確認・承認]
        N --> O[Scribe: チケットクローズ]
    end
```

## 並列化ポイント

| フェーズ | 並列実行するメンバー | 効果 |
|----------|---------------------|------|
| 実装 | 複数Coder（タスク分解後） | 実装時間短縮 |
| テスト | 複数Tester（独立テスト） | テスト時間短縮 |

## シーケンス図（詳細）

```mermaid
sequenceDiagram
    participant PO as PO（ユーザ）
    participant L as Leader
    participant S as Scribe
    participant C as Coder
    participant T as Tester
    participant RM as Redmine

    Note over PO,RM: 要件定義フェーズ
    PO->>L: 要件伝達
    L->>S: チケット起票依頼
    S->>RM: Epic/Feature/UserStory起票
    S-->>L: issue_100

    Note over PO,RM: 技術調査・意思決定フェーズ
    L->>RM: 既存チケット・コメント参照
    L->>PO: pro/con提示
    PO->>L: 方針決定
    L->>S: タスク分解依頼
    S->>RM: 子チケット起票
    S-->>L: issue_101, issue_102

    Note over PO,RM: 実装フェーズ【並列可】
    par 並列実行
        L->>C: issue_101（実装指示）
        C->>RM: チケット読取→実装→結果コメント追記
        C-->>L: issue_101完了
    and
        L->>C: issue_102（実装指示）
        C->>RM: チケット読取→実装→結果コメント追記
        C-->>L: issue_102完了
    end

    Note over PO,RM: レビューフェーズ
    L->>RM: コメント参照・diff確認
    alt レビューNG
        L->>C: issue_101修正指示
        C->>RM: 修正・結果コメント追記
        C-->>L: issue_101修正完了
        L->>RM: 再レビュー
    end

    Note over PO,RM: テストフェーズ
    L->>T: issue_101, issue_102（テスト依頼）
    T->>RM: チケット読取→テスト→結果コメント追記
    T-->>L: issue_101, issue_102完了

    Note over PO,RM: 受入フェーズ
    L->>PO: 完了報告
    PO-->>L: 承認
    L->>S: チケットクローズ依頼
    S->>RM: ステータス更新
```

## 通信パターン

### issue_idポインタ渡し

```
Leader → Coder:  "issue_101を実装してください"
Coder → Leader:  "issue_101完了"
Coder → Redmine: 詳細な実装内容・コミットハッシュ・懸念事項をコメント追記
Leader → Redmine: コメント参照してレビュー
```

### sendmessage_guardの制御

sendmessage_guardにより、メンバー間のメッセージにissue_idパターンが強制される。長文メッセージやチケットID無しの通信はブロックされる。

### LeaderConstraintHookの制御

subagent（チームメンバー）が存在する場合、leaderのEdit/Write/NotebookEdit等のファイル変更ツールがブロックされる。leaderは必ずcoderに委譲する。

## 制御機構との関係

```mermaid
flowchart LR
    subgraph Guard["claude-nagger ガードレール"]
        SMG["sendmessage_guard"]
        LCH["LeaderConstraintHook"]
        SSH["session_startup_hook"]
    end

    subgraph AT["Agent Teams"]
        L["Leader"]
        C["Coder"]
        T["Tester"]
        S["Scribe"]
    end

    SMG -->|issue_idパターン強制| L
    SMG -->|issue_idパターン強制| C
    SMG -->|issue_idパターン強制| T
    SMG -->|issue_idパターン強制| S
    LCH -->|Edit/Writeブロック| L
    SSH -->|規約注入| C
    SSH -->|規約注入| T
    SSH -->|規約注入| S
```

## 注意事項

- メンバー間直接通信は可能だが、内容はissue_idのみに制限（sendmessage_guard）
- 詳細情報の受け渡しは必ずRedmineコメント経由
- Leaderは技術調査が必要な場合、general-purposeサブエージェントを個別に起動可能
- 各メンバーは独立したClaude Codeセッションとして動作するため、コンテキストは完全分離
